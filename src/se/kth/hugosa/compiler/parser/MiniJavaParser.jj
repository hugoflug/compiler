options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
  package se.kth.hugosa.compiler.parser;
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)

TOKEN : {
     < CLASS: "class" >
  |  < PUBLIC : "public" >
  |  < STATIC : "static" >
  |  < VOID : "void" >
  |  < STRING : "String" >
  |  < RETURN : "return" >
  |  < INT : "int" >
  |  < LBRACKET : "[" >
  |  < RBRACKET : "]" >
  |  < BOOLEAN : "boolean" >
  |  < LBRACE : "{" >
  |  < RBRACE : "}" >
  |  < LPAREN : "(" >
  |  < RPAREN : ")" >
  |  < IF : "if" >
  |  < ELSE : "else" >
  |  < WHILE : "while" >
  |  < SYSO : "System.out.println" >
  |  < DOT : "." >
  |  < LENGTH : "length" >
  |  < TRUE : "true" >
  |  < FALSE : "false" >
  |  < THIS : "this" >
  |  < NEW : "new" >
  |  < EXCLMARK : "!" >
  |  < AND : "&&" >
  |  < LT : "<" >
  |  < PLUS : "+" >
  |  < MINUS : "-" >
  |  < MULT : "*" >
  |  < COMMA : "," >
  |  < ASSIGN : "=" >
  |  < SEMICOLON : ";" >
  |  < ID : ((["a"-"z"]|["A"-"Z"]|"_")(["a"-"z"]|["A"-"Z"]|["0"-"9"]|"_")*) >
  |  < INT_LIT : ("0"|(["1"-"9"](["0"-"9"])*)) >
}

SKIP : {
     " "
  |  "\t"
  |  "\n"
  |  "\r"
  |  "\f"
}

void Program() : {}
{
    MainClass() (ClassDecl())*
}

void MainClass() : {}
{
    <CLASS> <ID> <LBRACE> <PUBLIC> <STATIC> <VOID> <ID> <LPAREN> <STRING> <LBRACKET> <RBRACKET> <ID> <RPAREN> <LBRACE>
       (LOOKAHEAD(2) VarDecl())*
       (Stmt())*
    <RBRACE>
    <RBRACE>
}

void ClassDecl() : {}
{
    <CLASS> <ID> <LBRACE> (VarDecl())* (MethodDecl())* <RBRACE>
}

void Exp() : {}
{
    ExpLT() (<AND> ExpLT())*
}

void ExpLT() : {}
{
    ExpPlusMinus() (<LT> ExpPlusMinus())*
}

void ExpPlusMinus() : {}
{
    ExpMult() ((<PLUS>|<MINUS>) ExpMult())*
}

void ExpMult() : {}
{
    ExpInfo() (<MULT> ExpInfo())*
}

void ExpInfo() : {}
{
    ExpParens() (LOOKAHEAD(2)
                 <DOT> <LENGTH>
               | <DOT> <ID> <LPAREN> ExpList() <RPAREN>
               | <LBRACKET> Exp() <RBRACKET>
               | {})

}

void ExpList() : {}
{
    [Exp() (<COMMA> Exp())*]
}

void ExpParens() : {}
{
    <LPAREN> Exp() <RPAREN>
  | ExpVal()
}

void ExpVal() : {}
{
    <INT_LIT>
  | <TRUE>
  | <FALSE>
  | <THIS>
  | <ID>
  | LOOKAHEAD(2)
    <NEW> <INT> <LBRACKET> Exp() <RBRACKET>
  | <NEW> <ID> <LPAREN> <RPAREN>
}

void VarDecl() : {}
{
    Type() <ID> <SEMICOLON>
}

void MethodDecl() : {}
{
    <PUBLIC> Type() <ID> <LPAREN> FormalList() <RPAREN> <LBRACE>
        (LOOKAHEAD(2) VarDecl())* (Stmt())* <RETURN> Exp() <SEMICOLON>
    <RBRACE>
}

void FormalList() : {}
{
    [Type() <ID> (<COMMA> Type() <ID>)*]
}

void Type() : {}
{
      LOOKAHEAD(2)
      <INT> <LBRACKET> <RBRACKET>
    | <BOOLEAN>
    | <INT>
    | <ID>
}

void Stmt() : {}
{
    <LBRACE> (Stmt())* <RBRACE>
  | <IF> <LPAREN> Exp() <RPAREN> Stmt() <ELSE> Stmt()
  | <WHILE> <LPAREN> Exp() <RPAREN> Stmt()
  | <SYSO> <LPAREN> Exp() <RPAREN> <SEMICOLON>
  | LOOKAHEAD(2)
    <ID> <ASSIGN> Exp() <SEMICOLON>
  | <ID> <LBRACKET> Exp() <RBRACKET> <ASSIGN> Exp() <SEMICOLON>
}