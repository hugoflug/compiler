options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
  package se.kth.hugosa.compiler.parser;
  import se.kth.hugosa.compiler.ast.*;
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)

TOKEN : {
     < CLASS: "class" >
  |  < PUBLIC : "public" >
  |  < STATIC : "static" >
  |  < VOID : "void" >
  |  < STRING : "String" >
  |  < RETURN : "return" >
  |  < INT : "int" >
  |  < LBRACKET : "[" >
  |  < RBRACKET : "]" >
  |  < BOOLEAN : "boolean" >
  |  < LBRACE : "{" >
  |  < RBRACE : "}" >
  |  < LPAREN : "(" >
  |  < RPAREN : ")" >
  |  < IF : "if" >
  |  < ELSE : "else" >
  |  < WHILE : "while" >
  |  < SYSO : "System.out.println" >
  |  < DOT : "." >
  |  < LENGTH : "length" >
  |  < TRUE : "true" >
  |  < FALSE : "false" >
  |  < THIS : "this" >
  |  < NEW : "new" >
  |  < EXCLMARK : "!" >
  |  < AND : "&&" >
  |  < LT : "<" >
  |  < PLUS : "+" >
  |  < MINUS : "-" >
  |  < MULT : "*" >
  |  < COMMA : "," >
  |  < ASSIGN : "=" >
  |  < SEMICOLON : ";" >
  |  < ID : ((["a"-"z"]|["A"-"Z"]|"_")(["a"-"z"]|["A"-"Z"]|["0"-"9"]|"_")*) >
  |  < INT_LIT : ("0"|(["1"-"9"](["0"-"9"])*)) >
}

SKIP : {
     " "
  |  "\t"
  |  "\n"
  |  "\r"
  |  "\f"
}

void Program() :{}
{
    MainClass() (ClassDecl())*
}

void MainClass() : {}
{
    <CLASS> <ID> <LBRACE> <PUBLIC> <STATIC> <VOID> <ID> <LPAREN> <STRING> <LBRACKET> <RBRACKET> <ID> <RPAREN> <LBRACE>
       (LOOKAHEAD(2) VarDecl())*
       (Stmt())*
    <RBRACE>
    <RBRACE>
}

void ClassDecl() : {}
{
    <CLASS> <ID> <LBRACE> (VarDecl())* (MethodDecl())* <RBRACE>
}

void Exp() : {}
{
    ExpLT() (<AND> ExpLT())*
}

void ExpLT() : {}
{
    ExpPlusMinus() (<LT> ExpPlusMinus())*
}

void ExpPlusMinus() : {}
{
    ExpMult() ((<PLUS>|<MINUS>) ExpMult())*
}

void ExpMult() :
{
    Exp exp1;
    Exp exp2;
}
{
    exp1 = ExpInfo() (<MULT> ExpInfo())*
}

void ExpInfo() : {}
{
    [<EXCLMARK>]
    ExpParens() (LOOKAHEAD(2)
                 <DOT> <LENGTH>
               | <DOT> <ID> <LPAREN> ExpList() <RPAREN>
               | <LBRACKET> Exp() <RBRACKET>
               | {})

}

ExpList ExpList() :
{
    ExpList expList = new ExpList();
    Exp exp;
}
{
    [exp = Exp() { expList.addExp(exp); }(<COMMA> exp = Exp() { expList.addExp(exp); })*]
    { return expList; }
}

Exp ExpParens() :
{
    Exp value;
}
{
    <LPAREN> value = Exp() <RPAREN>
    | value = ExpVal()
    { return value; }
}

Exp ExpVal() :
{
   Token token;
   Exp value;
}
{
   (token = <INT_LIT> { value = new IntLit(Integer.parseInt(token.image)); }
  | token = <TRUE> { value = new True(); }
  | token = <FALSE> { value = new False(); }
  | token = <THIS> { value = new This(); }
  | token = <ID> { value = new Identifier(token.image); }
  | LOOKAHEAD(2)
    <NEW> <INT> <LBRACKET> token = Exp() <RBRACKET> { value = new NewArray(value); }
  | <NEW> token = <ID> <LPAREN> <RPAREN>) { value = new NewObject(new Identifier(token.image)); }

  { return value; }
}

VarDecl VarDecl() :
{
    VarDecl varDecl;
    Token id;
    Type type;
}
{
    type = Type()
    id = <ID>
    <SEMICOLON>
    { return new VarDecl(type, new Identifier(id.image)); }
}

MethodDecl MethodDecl() :
{
    Type type;
    Token id;
    Identifier name;
    Formal formal;
    FormalList argList;
    VarDeclList varDecls = new VarDeclList();
    VarDecl varDecl,
    Stmt stmt;
    StmtList statements = new StmtList();
    Exp returnValue;
}
{
    <PUBLIC>
    type = Type()
    name = <ID> { name = new Identifier(token.image);}
    <LPAREN> argList = FormalList() <RPAREN> <LBRACE>
    (LOOKAHEAD(2) varDecl = VarDecl() {varDecls.addVarDecl(varDecl);})*
    (stmt = Stmt() {statements.addStmt(stmt);})*
    <RETURN> returnValue = Exp() <SEMICOLON>
    <RBRACE>
    { return new MethodDecl(type, name, argList, varDecls, statements, returnValue); }
}

FormalList FormalList() :
{
    FormalList formalList = new FormalList();
    Type type;
    Token id;
    Identifier name;
}
{
    [type = Type() id = <ID> { formalList.addFormal(new Formal(type, new Identifier(id.image))); }
    (<COMMA> type = Type() id = <ID> { formalList.addFormal(new Formal(type, new Identifier(id.image))); } )*]

    { return formalList; }
}

Type Type() :
{
    Type type;
    Token id
}
{
      LOOKAHEAD(2)
      <INT> <LBRACKET> <RBRACKET> { type = new IntArrayType(); }
    | <BOOLEAN> { type = new BooleanType(); }
    | <INT> { type = new IntType(); }
    | id = <ID> { type = new ObjectType(id.image); }

    { return type; }
}

Stmt Stmt() :
{
    Stmt stmt;
    Stmt stmt2;
    StmtList stmtList = new StmtList();
    Exp exp1;
    Exp exp2;
    Token id;
}
{
    <LBRACE> (stmt = Stmt() { stmtList.addStmt(stmt); })* <RBRACE> { stmt = new Block(stmtList); }
  | <IF> <LPAREN> exp1 = Exp() <RPAREN> stmt = Stmt() <ELSE> stmt2 = Stmt() { stmt = new If(exp1, stmt, stmt2); }
  | <WHILE> <LPAREN> exp1 = Exp() <RPAREN> stmt = Stmt() { stmt = new While(exp1, stmt); }
  | <SYSO> <LPAREN> exp1 = Exp() <RPAREN> <SEMICOLON> { stmt = new Syso(exp1); }
  | LOOKAHEAD(2)
    id = <ID> <ASSIGN> exp1 = Exp() <SEMICOLON> { stmt = new Assign(new Identifier(id.image), exp1); }
  | id = <ID> <LBRACKET> exp1 = Exp() <RBRACKET> <ASSIGN> exp2 = Exp() <SEMICOLON> { stmt = new ArrayAssign(new Identifier(id.image), exp1, exp2); }

  { return stmt; }
}